#include <ros/ros.h>
#include <iostream>
#include <cstring>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <etsi_its_msgs/CPM.h>
//#include <flatbuffers/all_interface_generated.h> // This was generated by `flatc`.
//#include "flatbuffers/all_interface_generated.h" // This was generated by `flatc`.
#include "all_interface_generated.h" // This was generated by `flatc`.



using namespace Gos;

#define PORT 3000
#define BUFFER_SIZE 4096

void decode_received_cpm() {
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    uint8_t buffer[BUFFER_SIZE];
    
    // Create a UDP socket
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }
    
    // Configure server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    // Bind the socket to the server address
    if (bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        exit(1);
    }
    
    // Receive the message from the client
    socklen_t client_addr_len = sizeof(client_addr);
    ssize_t received_bytes = recvfrom(sockfd, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, &client_addr_len);
    if (received_bytes == -1) {
        perror("recvfrom");
        exit(1);
    }

    std::cout << "Received message from client: " << buffer << std::endl;

    // Build up a serialized buffer algorithmically:
    flatbuffers::FlatBufferBuilder builder;
    auto gossip = GetGossipMessage(buffer);

    auto gossip_type = gossip->gossip_type();
    
    if (gossip_type == GossipType_FacilityLayerReception) {
        auto fac_rx = static_cast<const FacilityLayerReception*>(gossip->gossip()); // Requires `static_cast`

        std::cout << "Received a facility layer reception message" << std::endl;

        auto union_msg = fac_rx->msg_type();


        if(union_msg == FacilityLayerMessage_CAMessage){
            std::cout << "Received a CAM " << std::endl;
        }
        else if(union_msg == FacilityLayerMessage_CPMessage){
            std::cout << "Received a CPM " << std::endl;
            auto cpm = static_cast<const CPMessage*>(fac_rx->msg());
            const Gos::ItsPduHeader *header = cpm->header();
            std::cout << "Station id " << header->station_id() << std::endl;
            auto generation_delt_time = cpm->generation_delta_time();
            std::cout << "generation_delt_time " << generation_delt_time << std::endl;
            
            const Gos::ManagementContainer *mngmt_cntr = cpm->mgmt_container();
            std::cout << "reference managment container info: " << std::endl;
            //std::cout << "reference time: " << mngmt_cntr->reference_time() << std::endl;
            const Gos::ReferencePosition *ref_pos = mngmt_cntr->reference_position();
            std::cout << "reference position of the sending vehicle: lat = " << ref_pos->latitude() << ", long = " << ref_pos->longitude() << std::endl;
            std::cout << "station type: " << mngmt_cntr->station_type() << std::endl;

         
            const Gos::CpmPayload* c_payload = cpm->cpm_payload();
            std::cout << "entered" << std::endl;
            const Gos::OriginatingStationsContainer *o_stn_ctnr = c_payload->originating_stations_container();
            std::cout << "entered" << std::endl;

            const Gos::OriginatingVehicleContainer *o_veh_ctnr = o_stn_ctnr->originating_vehicle_container();
            const Gos::Wgs84Angle *o_veh_orntn_angle = o_veh_ctnr->orientation_angle();
            std::cout << "vehicle orientation angle value: " << o_veh_orntn_angle->wgs_angle_value() << ", confidence: "<< o_veh_orntn_angle->wgs84_angle_confidence() << std::endl;
            
            
            const Gos::PerceivedObjectContainer *pr_obj_cntr = c_payload->perceived_object_container();
            auto num_objs = pr_obj_cntr->number_of_perceived_objects();
            auto prcvd_objs = pr_obj_cntr->perceived_objects();
            std::cout << "number of perceived objects: " << num_objs << std::endl;
            
            for(auto obj : *prcvd_objs){

                std::cout << "Obj id " << obj->object_id() << std::endl;
                std::cout << "Obj delta " << obj->measurement_delta_time() << " " << std::endl;

                //object position
                const Gos::CartesianPosition3dWithConfidence * pos = obj->position();
                using cart_coord = const Gos::CartesianCoordinateWithConfidence;
                cart_coord* x_cord = pos->x_cord();
                cart_coord* y_cord = pos->y_cord();
                cart_coord* z_cord = pos->z_cord();
                std::cout << "Object positon: x-" << x_cord << ", y-" <<  y_cord << ", z-" << z_cord << std::endl;

                //object velocity
                const Gos::Velocity3dWithConfidence *vel = obj->velocity();

                const Gos::VelocityPolarWithZ *pol_vel = vel->polar_velocity();
                const Gos::Speed *vel_mag = pol_vel->velocity_magnitude();
                std::cout << "VelocityPolarWithZ - speed: value= " << vel_mag->value() << ", conf = " << vel_mag->confidence() << std::endl;
                const Gos::CartesianAngle *vel_dirct = pol_vel->velocity_direction();
                std::cout << "VelocityPolarWithZ - direction: value = " << vel_dirct->cartesian_value() << ", conf = " << vel_dirct->cartesian_angle_confidence() << std::endl;
                const Gos::VelocityComponent *pol_z_vel = pol_vel->z_velocity();
                std::cout << "VelocityPolarWithZ - Z component: value= " << pol_z_vel->vel_comp_value() << ", conf = " << pol_z_vel->speed_confidence() << std::endl;

                const Gos::VelocityCartesian *cart_vel = vel->cartesian_velocity();
                const Gos::VelocityComponent *x_vel = cart_vel->x_velocity();
                const Gos::VelocityComponent *y_vel = cart_vel->y_velocity();
                const Gos::VelocityComponent *z_vel = cart_vel->z_velocity();
                std::cout << "Object Cartesian velocity (value, confidence): x- " << x_vel->vel_comp_value() <<", "<<  x_vel->speed_confidence() 
                                                                       << ", y- " << y_vel->vel_comp_value()<<", "<< y_vel->speed_confidence() 
                                                                       << ", z-" << z_vel->vel_comp_value()<<", "<< z_vel->speed_confidence() << std::endl;

                //object dimensions
                using obj_dim = const Gos::ObjectDimension;
                obj_dim* z_dim = obj->object_dimension_z();
                obj_dim* y_dim = obj->object_dimension_y();
                obj_dim* x_dim = obj->object_dimension_x();

                std::cout << "Object dimensions:(value, confidence): x- " << x_dim->value() <<", "<<  x_dim->confidence() 
                                                               << ", y- " << y_dim->value()<<", "<< y_dim->confidence() 
                                                               << ", z-" << z_dim->value()<<", "<< z_dim->confidence() << std::endl;

                
                //object age
                std::cout << "object age: " << obj->object_age() << std::endl;

                
                auto obj_classifications_list = obj->classification();

                for(auto obj_cls : *obj_classifications_list){
                    const Gos::ObjectClass *obj_class = obj_cls->object_class();
                    std::cout << "vehicle subclass: " << static_cast<int32_t>(obj_class->vehicle_sub_class()) << std::endl;
                    std::cout << "object class confidence: " << obj_cls->confidence() << std::endl;

                }
                

                //map position
                const Gos::MapPosition *map_pos = obj->map_position();

                const Gos::MapReference *m_ref = map_pos->map_reference();
                const Gos::RoadSegmentReferenceID *rd_seg = m_ref->road_segment();
                std::cout << "MapPosition/roadseg: region = " << rd_seg->region()<< ", id: "<< rd_seg->id() << std::endl;
                const Gos::IntersectionReferenceID *intrsctn_id = m_ref->intersection();
                std::cout << "MapPosition/intersection: region = " << intrsctn_id->region()<< ", id: "<< intrsctn_id->id() << std::endl;


                std::cout << "lane id: ", map_pos->lane_id();
                std::cout << "conn id: ", map_pos->connection_id();
                const Gos::LongitudinalLanePosition *long_lane_pos = map_pos->longitudinal_lane_position();
                std::cout << "LongitudinalLanePosition - value= " << long_lane_pos->longitudinal_lane_position_value() << ", conf = " << long_lane_pos->longitudinal_lane_position_confidence() << std::endl;

            }
        }
    }
}



int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, "cpm_receive_node");

    // Create a ROS node handle
    ros::NodeHandle nh;

    // Create a ROS subscriber
    //ros::Subscriber sub = nh.subscribe("cpm_provided", 10, &serialize_cpm);

    decode_received_cpm();

    // ROS main loop
    ros::spin();

    return 0;
}